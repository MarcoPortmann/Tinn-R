unit uLexerCommands;

interface

uses vcl.dialogs, DScintilla, DScintillaTypes, ufrmMain, ufrmEditor, ufrmRTerm, ufrmTools, uModDados, trUtils, Vcl.Graphics, PerlRegEx, windows, System.SysUtils, SciKeyBindings;

procedure ApplyLexer(iLexerId: Integer; sciEditor: TDScintilla);
//procedure SetLexer(Editor: TDSCintilla; LanguageString: String);
procedure SetScintillaProperties(var Editor: TDScintilla);
procedure SetScintillaKeyStrokes(var Editor: TDScintilla);
procedure LoopAllEditorsReSetProperties;
procedure ToggleWrapMode(Editor: TDSCintilla; iWrapStyle: Integer);
procedure UpdateLexerKeyWords;
implementation

{
procedure SetLexer(Editor: TDSCintilla; LanguageString: String);

  procedure SetColors(const Style: Integer; const Fore: Integer;
    const Back: TColor = clWindow; const Bold: Boolean = False;
    const Italic: Boolean = False; const Underline: Boolean = False;
    const Font: string = 'Courier New'; const Size: Integer = 10);
  begin
    Editor.StyleSetBack(Style, ColorToRGB(Back));
    Editor.StyleSetFore(Style, ColorToRGB(Fore));
    Editor.StyleSetFont(Style, Font);
    Editor.StyleSetSize(Style, Size);
    Editor.StyleSetBold(Style, Bold);
    Editor.StyleSetItalic(Style, Italic);
    Editor.StyleSetUnderline(Style, Underline);
  end;

begin

  Editor.SetLexerLanguage(LanguageString);
  Editor.SetLexer(SCLEX_R);

  SetColors(SCE_R_DEFAULT, clBlack);
  SetColors(SCE_R_COMMENT, clGray);
  SetColors(SCE_R_KWORD, clFuchsia);
  SetColors(SCE_R_BASEKWORD, clMaroon);
  SetColors(SCE_R_OTHERKWORD, clBlack);

  SetColors(SCE_R_NUMBER, clBlue);
  SetColors(SCE_R_STRING, clGreen);
  SetColors(SCE_R_STRING2, clGreen);
  SetColors(SCE_R_OPERATOR, clBlue);

  SetColors(SCE_R_IDENTIFIER, clNavy);
  SetColors(SCE_R_INFIX, clNavy);
  SetColors(SCE_R_INFIXEOL, clGray);

  Editor.StyleSetFore(STYLE_BRACELIGHT, cllime);
  Editor.StyleSetFore(STYLE_BRACEBAD, clred);

end;}


procedure ApplyLexer(iLexerId: Integer; sciEditor: TDScintilla);

  procedure SetColors(const iStyle: Integer; const iFore: Integer;
    const iBack: TColor = clWindow; const bBold: Boolean = False;
    const bItalic: Boolean = False; const bUnderline: Boolean = False;
    const sFont: string = 'Courier New'; const iSize: Integer = 10);
  begin
  with sciEditor do
  begin
    StyleSetBack(iStyle, ColorToRGB(iBack));
    StyleSetFore(iStyle, ColorToRGB(iFore));
    StyleSetFont(iStyle, sFont);
    StyleSetSize(iStyle, iSize);
    StyleSetBold(iStyle, bBold);
    StyleSetItalic(iStyle, bItalic);
    StyleSetUnderline(iStyle, bUnderline);
  end;
  end;

begin
with ModDados.cdIdentifiersCurrent do
begin
  Filter := 'LexerId = '+inttostr(iLexerId);
  Filtered := true;
  Refresh;

  sciEditor.SetLexer(iLexerId);
  First;
  while not Eof do
  begin
    if FieldByName('IdentifierType').AsInteger = 1 then
      SetColors(FieldByName('IdentifierId').AsInteger,
                FieldByName('FGColor').AsInteger,
                FieldByName('BGColor').AsInteger,
                (FieldByName('Bold').AsInteger = 1),
                (FieldByName('Italic').AsInteger = 1),
                (FieldByName('Underline').AsInteger = 1),
                FieldByName('FontName').AsString,
                FieldByName('FontSize').AsInteger
               );

    Next;
  end;
end;
end;






procedure SetScintillaKeyStrokes(var Editor: TDScintilla);
var  KeyCommands: TSciKeyCommandCollection;
begin
  with Editor do
  begin

    if FileExists(frmTinnMain.sPathEditor_KeyStrokes) then
    begin
      KeyCommands := TSciKeyCommandCollection.create(Editor);
      if not LoadKeyCommands(KeyCommands, frmTinnMain.sPathEditor_KeyStrokes) then
      begin
        KeyCommands.ResetDefaultCommands;
        SaveKeyCommands(KeyCommands, frmTinnMain.sPathEditor_KeyStrokes);
      end;
      //KeyCommands := frmTinnMain.EditorKeystrokes;
      KeyCommands.Free;
    end;
  end;
end;


procedure SetScintillaProperties(var Editor: TDScintilla);
var i : Integer;
//   KeyCommands: TSciKeyCommandCollection;
begin

  with Editor do
  begin
  with frmTinnMain.ifEditor do
  begin

  // Has to be updated later: for the moment just lexers given by the editor form
  // and set it to R for the remaining editors.
  // Add a customer option for the console later.

  if (Editor.Parent.ClassName = 'TfrmEditor') then
    ApplyLexer( (Editor.Parent AS TfrmEditor).GetEditorLexerId, Editor)
  else ApplyLexer(86, Editor);


    SetScintillaKeyStrokes(Editor);

    Editor.SetCodePage(CP_ACP);

    if (frmTinnMain.actLineNumbersVisible.Checked) and (Editor.Parent.ClassName = 'TfrmEditor') then
        Editor.SetMarginWidthN(MARGIN_LINE_NUMBERS, Editor.TextWidth(Editor.MarginGetStyle(Editor.GetLineCount),inttostr(Editor.GetLineCount))+8)
      else  Editor.SetMarginWidthN(MARGIN_LINE_NUMBERS, 0);

    if (Editor.Parent.ClassName = 'TfrmEditor') then
    begin
      Editor.SetProperty('fold', '1');
      Editor.SetProperty('fold.html', '1');
      Editor.SetMarginTypeN(MARGIN_CODE_FOLDING, SC_MARGIN_SYMBOL);
      Editor.SetMarginMaskN(MARGIN_CODE_FOLDING, SC_MASK_FOLDERS);
    end;

    if (frmTinnMain.actFoldingVisible.Checked) and (Editor.Parent.ClassName = 'TfrmEditor') then
       Editor.SetMarginWidthN(MARGIN_CODE_FOLDING, 20)
       else  Editor.SetMarginWidthN(MARGIN_CODE_FOLDING, 0);



    if (Editor.Parent.ClassName = 'TfrmEditor') then
    begin
      Editor.SetMarginTypeN(MARGIN_BOOKMARKS, SC_MARGIN_SYMBOL);
      Editor.SetMarginMaskN(MARGIN_BOOKMARKS, 1023);
      Editor.SetMarginSensitiveN(MARGIN_BOOKMARKS, True);

      for i := 0 to 9 do
        Editor.MarkerDefine(i, SC_MARK_CHARACTER+ord(inttostr(i)[1]));

      Editor.MarkerDefine(SC_MARKNUM_FOLDER, SC_MARK_PLUS);
      Editor.MarkerDefine(SC_MARKNUM_FOLDEROPEN, SC_MARK_MINUS);
      Editor.MarkerDefine(SC_MARKNUM_FOLDEREND, SC_MARK_EMPTY);
      Editor.MarkerDefine(SC_MARKNUM_FOLDERMIDTAIL, SC_MARK_EMPTY);
      Editor.MarkerDefine(SC_MARKNUM_FOLDEROPENMID, SC_MARK_EMPTY);
      Editor.MarkerDefine(SC_MARKNUM_FOLDERSUB, SC_MARK_EMPTY);
      Editor.MarkerDefine(SC_MARKNUM_FOLDERTAIL, SC_MARK_EMPTY);

      Editor.SetMarginSensitiveN(MARGIN_CODE_FOLDING, True);
    end;

    if (frmTinnMain.actMarkersVisible.Checked) and (Editor.Parent.ClassName = 'TfrmEditor') then
      Editor.SetMarginWidthN(MARGIN_BOOKMARKS, 20)
      else   Editor.SetMarginWidthN(MARGIN_BOOKMARKS, 0);



    Editor.SetVirtualSpaceOptions(2);
    Editor.SetUseTabs( (ReadBool('Scintilla', 'TabSpaces',  true) = false)  );
    Editor.SetTabWidth( ReadInteger('Scintilla', 'TabWidth',  2)  );
    // Left margin

{    sGutterColor.Brush.Color := WriteInteger('Scintilla', 'MarginColor',     clBtnFace);

    cbGutterFont.Checked := ReadBool('Scintilla', 'MarginUse',          false);
    lblGutterFont.Font.Color := ReadInteger('Scintilla', 'MarginFontColor', clBlack);
    lblGutterFont.Font.Size := ReadInteger('Scintilla', 'MarginFontSize',  8);
    lblGutterFont.Font.Name := WriteString('Scintilla', 'MarginFontName', 'Arial' );

    // Right margin
    eRightEdge.Text := inttostr(ReadInteger('Scintilla', 'RightEdgeColumn', 80));
    sRightEdgeColor.Brush.Color :=  ReadInteger('Scintilla', 'RightEdgeColor',  clGreen);

    // Tab

    eTabWidth.Text := inttostr(ReadInteger('Scintilla', 'TabWidth',  2));


    // Font

    labFont.Font.Color := ReadInteger('Scintilla', 'StdFontColor',   clBlack);
    labFont.Font.Size  := ReadInteger('Scintilla', 'StdFontSize',    10);
    labFont.Font.Name  := ReadInteger('Scintilla', 'StdFontName',    'Courier New');
                                                        }
    // Special Characters
  //  ToogleSpecialChars(ReadBool('Scintilla', 'SpecialChars', false));

  {  ToogleLineNumbers(bOption: Boolean);
    ToogleSpecialChars(bChecked: Boolean); }

  //Editor.StyleSetFore(STYLE_BRACELIGHT, iBraceLightFore);
  //Editor.StyleSetBack(STYLE_BRACELIGHT, iBraceLightBack);
  //Editor.StyleSetFore(STYLE_BRACEBAD, clred);

  if frmTinnMain.bHighlightActiveLine then
  begin
    Editor.SetCaretLineVisible(true);
    Editor.SetCaretLineBack(frmTinnMain.iHighlightActiveLineColor);
  end;

    if (Editor.Name <> 'sciIO') and ((Editor.Name <> 'sciLog')) then
      ToggleWrapMode(Editor, frmTinnMain.iEditorLineWrap);

    if (Editor.Name = 'sciIO')  then
      ToggleWrapMode(Editor, frmTinnMain.iIOLineWrap);

    if (Editor.Name = 'sciLog')  then
      ToggleWrapMode(Editor, frmTinnMain.iLogLineWrap);

  end;
  end;
end;

procedure LoopAllEditorsReSetProperties;
var
  i: integer;
begin
  if ( frmTinnMain.MDIChildCount > 0) then
    for i := (frmTinnMain.MDIChildCount - 1) downto 0 do
    begin
       SetScintillaProperties((frmTinnMain.MDIChildren[i] as TfrmEditor).sciEditor);
       if Assigned((frmTinnMain.MDIChildren[i] as TfrmEditor).sciEditor2) then
          SetScintillaProperties( (frmTinnMain.MDIChildren[i] as TfrmEditor).sciEditor);
          (frmTinnMain.MDIChildren[i] as TfrmEditor).Repaint;
    end;


  SetScintillaProperties(frmRTerm.SciIO);
  SetScintillaProperties(frmRTerm.SciLog);
end;

procedure ToggleWrapMode(Editor: TDSCintilla; iWrapStyle: Integer);
begin
  Editor.SetWrapMode(iWrapStyle);
  Editor.SetWrapVisualFlags(SC_WRAPVISUALFLAG_START);
end;


procedure UpdateLexerKeyWords;
var
  i: integer;
  KeyWordStringBase, KeyWordStringUser, sWord: String;
  function AlphaOnly(sstr: String): Boolean;
  var i: Integer;

  begin
    result := true;
    for i := 1 to length(sstr) do
      if not CharInSet(sstr[i], ['A' .. 'Z', 'a' .. 'z', '.', '0'..'9']) then
      begin
        result := false;
        break;
      end;

  end;
begin
  ModDados.sqldsRTest.Active := true;
  ModDados.sqldsRTest.Refresh;
  ModDados.cdRTest.Active := true;
  ModDados.cdRTest.Refresh;

  with ModDados do
  begin
   cdRTest.First;
   while not cdRTest.Eof do
   begin
     sWord := cdRTest.FieldByName('Name').AsString;

      if AlphaOnly(sWord) then

     //if (ansipos(',', sWord)=0) AND (ansipos('.', sWord)=0) AND (ansipos('_', sWord)=0) AND (ansipos('<', sWord)=0) then
       KeyWordStringBase := KeyWordStringBase + ' ' + sWord;
     cdRTest.Next;
   end;
  end;



  ModDados.sqldsRUser.Active := true;
  ModDados.sqldsRUser.Refresh;
  ModDados.cdRUser.Active := true;
  ModDados.cdRUser.Refresh;

  with ModDados do
  begin
   cdRUser.First;
   while not cdRUser.Eof do
   begin
     sWord := cdRUser.FieldByName('Name').AsString;

      if AlphaOnly(sWord) then

     //if (ansipos(',', sWord)=0) AND (ansipos('.', sWord)=0) AND (ansipos('_', sWord)=0) AND (ansipos('<', sWord)=0) then
       KeyWordStringUser := KeyWordStringUser + ' ' + sWord;
     cdRUser.Next;
   end;
  end;




  if ( frmTinnMain.MDIChildCount > 0) then
    for i := (frmTinnMain.MDIChildCount - 1) downto 0 do
    begin

     //  if Assigned((frmTinnMain.MDIChildren[i] as TfrmEditor).sciEditor2) then
       begin
        with    (frmTinnMain.MDIChildren[i] as TfrmEditor).sciEditor do
        begin
          SetPunctuationChars(StringReplace(GetPunctuationChars, '.', '',         [rfReplaceAll, rfIgnoreCase]));
          // SetKeyWords(SCE_R_BASEKWORD, KeyWordString);
          // SetKeyWords(1, KeyWordString);
          SetKeyWords(1, KeyWordStringBase);
          SetKeyWords(2, KeyWordStringUser);

          // SetKeyWords(0, KeyWordString);



        end;
          //  (frmTinnMain.MDIChildren[i] as TfrmEditor).sciEditor.StyleSetFore(SCE_R_KWORD, clFuchsia);


    {           (frmTinnMain.MDIChildren[i] as TfrmEditor).sciEditor.StyleSetFore(0, clRed);

           (frmTinnMain.MDIChildren[i] as TfrmEditor).sciEditor.SetKeyWords(SCE_R_KWord, KeyWordString);   }
    //       (frmTinnMain.MDIChildren[i] as TfrmEditor).sciEditor.SetKeyWords(1, KeyWordString);
     //        (frmTinnMain.MDIChildren[i] as TfrmEditor).sciEditor.SetKeyWords(2, KeyWordString);

       end;
    end;
end;

end.
